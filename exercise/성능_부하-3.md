## 프로세스 스케줄링과 프로세스 상태
`프로세스`는 간단히 프로그램이 OS에 의해 실행되고 있을 때 그 실행단위가 되는 개념이다.

예를 들어, ls 명령을 실행하면 ls의 바이너리 파일로부터 기계어 명령이 메모리로 전개되고<br>
CPU가 메모리로부터 명령을 꺼내어(fetch) 실행해간다.

명령을 실행하려면 
- ls 명령이 사용하고 있는 각종 메모리 영역의 주소
- 실행 중인 명령의 위치(프로그램 카운터)
- ls 명령이 오픈한 파일의 목록
등 다양한 주소가 필요하게 된다.

이러한 정보는 흩어져있는 것 보다, 실행 중인 프로그램마다 한 덩어리로 해서 처리하는 편이 더 나은 것은 분명하다.<br>
프로세스란 이 `프로그램의 명령`과 `실행에 필요한 정보`가 한 덩어리로 된 오프젝트를 말한다.

커널은 프로세스마다 `프로세스 디스크립터`라는 관리용 테이블을 생성한다.<br>
이 프로세스 디스크립터에 각종 실행시 정보가 저장된다.

커널은 이 프로세스 디스크립터군을 우선도가 높은 순으로 재배열해서<br>
그럴 듯하게 실행순으로 프로세스가 실행되도록 조정한다. -> 이 역할을 프로세스 스케줄러가 한다.

스케줄러는 프로세스를 상태별로 나누어 관리한다.<br>
프로세스 디스크립터에는 이 상태를 저장하는 영역(task_struct 구조체의 state 멤버)이 있다.

### 프로세스 디스크립터의 상태 구별
| 상태 | 설명 |
|---|---|
| TASK_RUNNING  | 실행 가능한 상태<br>CPU에 시간이 나면 언제든지 실행이 가능 |
| TASK_INTERRUPTIBLE  | 중단(interrupt)가능한 대기상태<br> 주로 복귀시간이 예측 불가능한 장시간의 대기상태<br>sleep이나 사용자로부터 입력대기 등 |
| TASK_UNINTERRUPTIBLE  | 중단 불가능한 대기상태<br>주로 단시간에 복귀할 경우의 대기상태<br>디스크 입출력 대기  |
| TASK_STOPPED  | 중지(suspend) 시그널을 받아서 실행 중된당 상태<br>재개(resume)될 때까지 스케줄링되지 않음  |
| TASK_ZOMBIE  | 좀비(zonbie)상태<br>자식 프로세스가 exit해서 부모 프로세스로 반환될 때까지의 상태  |

## Load Average로 환산되는 대기상태

프로세스가 수행하는 상태변화에는 4 가지로
- TASK_RUNNING이면서 실행중
- TASK_RUNNING
- TASK_INTERRUPTIBLE
- TASK_UNINTERRUPTIBLE

Load Average는 `대기 태스크의 평균수`이므로, `TASK_RUNNING이면서 실행중`이외에 3 가지가 포함될 것으로 생각되지만<br>
Load Average로 환산 되는 것은 `TASK_RUNNING`과 `TASK_UNINTERRUPTIBLE`이다.

즉, 아래의 두 상태가 수치화되어 표현된다.
- CPU를 사용하려고 해도 다른 프로세스가 CPU를 사용하고 있어서 기다리는 프로세스
- 계속해서 처리하고자 해도 디스크 입출력이 끝낼 때까지 기다려야하는 프로세스 

## Load Average가 보고하는 부하의 정체
하드웨어는 일정 주기로 CPU 중단 신호(interrupt)를 보낸다<br>
주기적으로 보내지는 신호라는 점에서 `타이머 인터럽트`라고 한다.

이 중단마다 CPU는 시간을 진행시키거나 실행 중인 프로세스가 CPU를 얼마나 사용했는지를 계산하는 등<br>
시간에 관련된 처리를 수행한다. 이 때, 타이머 인터럽트 마다 Load Average 값이 계산된다.

커널은 타이머 인터럽트가 발생했을 때 실행가능 상태인 태스크와 I/O대기인 태스크의 개수를 세어둔다.<br>
그 값을 단위시간으로 나눈 것이 Load Average 값으로 보고된다.

## ps 프로세스 상태를 확인하는 툴
TASK_RUNNING 등은 커널이 내부적으로 다루는 상태를 구별한 것이지만<br>
사용자 프로세스에서도 이러한 상태를 참조할 수 있다(ps나 top 명령을 통해)

그 중 ps를 보자면 아래와 같은 형태로 나타나며
```
# ps auxw
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root       674  0.0  1.7 474024 17464 ?        Ssl  12:01   0:01 /usr/bin/python2 -Es /usr/sbin/tuned -l -P
root       675  0.0  0.4 112924  4344 ?        Ss   12:01   0:00 /usr/sbin/sshd -D -u0
root       676  0.0  4.4 266592 44936 ?        Ss   12:01   0:02 /usr/bin/python3 -s /usr/bin/salt-master
root       677  0.0  0.5 216704  5812 ?        Ssl  12:01   0:00 /usr/sbin/rsyslogd -n
root       869  0.0  0.2  89704  2140 ?        Ss   12:01   0:00 /usr/libexec/postfix/master -w
postfix    880  0.0  0.4  89876  4084 ?        S    12:01   0:00 qmgr -l -t unix -u
root       881  0.0  2.4 206392 24604 ?        S    12:01   0:00 /usr/bin/python3 -s /usr/bin/salt-master
```
이때 STAT열을 통해 프로세스의 상태를 알 수 있다.<br>
STAT에 대해서는
```
Here are the different values that the s, stat and state output specifiers (header "STAT" or "S") will display to describe the state of a process:
D    uninterruptible sleep (usually IO)                                   / TASK_UNINTERRUPTIBLE
R    running or runnable (on run queue)                                   / TASK_RUNNING
S    interruptible sleep (waiting for an event to complete)               / TASK_INTERRUPTIBLE
T    stopped by job control signal
t    stopped by debugger during the tracing
W    paging (not valid since the 2.6.xx kernel)
X    dead (should never be seen)
Z    defunct ("zombie") process, terminated but not reaped by its parent  / TASK_ZOMBIE

For BSD formats and when the stat keyword is used, additional characters may be displayed:
<    high-priority (not nice to other users)
N    low-priority (nice to other users)
L    has pages locked into memory (for real-time and custom IO)
s    is a session leader
l    is multi-threaded (using CLONE_THREAD, like NPTL pthreads do)
+    is in the foreground process group
```