# 병목 규명 작업의 기본적인 흐름
부하분산이란 말 그대로 여러 호스트로 처리를 분담 시키는 것을 의미한다.<br>
하지만 1대의 서버로도 처리할 수 있는 부하를 여러대의 서버로 분산하는 것은 본 말이 전도된 것이다.<br>
먼저 단일 서버의 성능을 충분히 끌어낸 다음에 여러 서버로 분산 시켜야 한다는 것이다.

병목을 규정하기 위한 작업을 크게 나누면 다음과 같다.
- Load Average 확인
- CPU I/O 중 병목 원인 조사

## 1. Load Average 확인
top,uptime등의 명령으로 Load Average를 확인한다.<br>
Load Average는 시스템 전체의 부하상황을 나타내는 지표지만, 이것으로는 병목의 원인이 어딘지 판단할 수 없다.<br>
Load Average를 시초로 해서 병목 지점에 대한 조사를 시작한다.

예를 들어 Load Average는 낮은데, 시스템의 전송량이 오르지 않을 경우도 가끔 있다.<br>
이럴때는 SW의 설정이나 오류, 네트워크, 원격 호스트측에 원인이 없는지 등을 살펴본다.

## 2. CPU, I/O 중 병목 원인 조사
Load Average가 높은 경우, 다음으로 CPU와 I/O 어느 쪽에 원인이 있는지를 조사한다.<br>
sar, vmstat로 시간 경과에 따라 cpu사용률이나, I/O 대기율의 추이를 확인하고 이를 참고해서 규명한다.

확인 후 다음 단계로 넘어간다.

### 2-1. CPU 부하가 높은 경우
아래와 같은 흐름으로 조사해간다.

- 사용자 프로그램 처리가 병목인지, 시스템 프로그램이 원인인지 확인한다.
  - top, sar로 확인한다.
- ps로 볼 수 있는 프로세스의 상태나, CPU 사용시간 등을 보면서 원인이 되고 있는 프로세스를 찾는다.
- 프로세스를 찾은 후 보다 상세하게 조사할 경우는 strace로 추적하거나, oprofile로 프로파일링을 해서 병목 지점을 좁혀간다.

일반적으로 CPU에 부하가 걸리고 있는 것은 다음 상황 중 하나다.
- 디스크나 메모리 용량 등 그 밖의 부분에서는 병목이 되지 않는 경우
  - 이러한 상황에서 시스템의 전송량에 문제가 있다면 서버 증설이나 프로그램의 로직, 알고리즘을 개선해서 대응한다.
- 프로그램이 폭주해서 CPU에 필요 이상의 부하가 걸리는 경우
  - 오류를 제거해서 프로그램이 폭주하지 않도록 대처한다.

### 2-2. I/O 부하가 높은 경우
I/O 부하가 높은 경우, 프로그램으로부터 입출력이 많아서 부하가 높거나<br>
스왑이 발생해서 디스크 액세스가 발생하고 있는 상황 중 하나일 경우가 대부분이다.(sar,vmstat로 스왑의 발생상황을 확인한다.)

- 스왑이 발생하고 있는 경우
  - 특정 프로세스가 극단적으로 메모리를 소비하고 있지 않은지를 ps로 확인한다.
    - ps auxww --sort -resident | head -n 10
  - 프로그램의 오류로 메모리를 지나치게 사용하고 있는 경우에 프로그램을 개선한다.
  - 탑재된 메모리가 부족한 경우 증설을 검토하거나, 어려운 경우 분산을 검토한다.

스왑이 발생하지 않고 디스크로의 입출력이 빈번하게 발생하고 있는 상황은 캐시에 필요한 메모리가 부족한 경우를 생각해볼 수 있다.

- 해당 서버가 저장하고 있는 데이터 용량과 증설 가능한 메모리량을 비교해서
  - 메모리 증설로 캐시 영역을 확대시킬 수 있는 경우는 메모리를 증설한다.
  - 메모리 증설로 대응할 수 없는 경우, 데이터 분산이나 캐시서버 도입 등을 검토한다.
    - 물론 프로그램을 개선해서 I/O 빈도를 줄이는 것도 검토한다.

  
이러한 구조를 통해 얻을 수 있는 이점으로는
- 실제 물리 메모리 용량 이상의 메모리를 다룰 수 있다.
- 메모리상에서는 흩어져 있는 영역을 연속된 하나의 메모리 영역으로 프로세스에게 보일 수 있다.
- 물리 메모리가 부족한 경우, 장시간 사용되지 않은 영역의 가상 메모리와 물리 메모리 영역의 매핑을 해제한다.
  - 해제된 데이터는 2차 기억장치에 저장해두고, 다시 필요해지면 원래로 되돌린다 = Swap
- 서로 다른 두개의 프로세스가 참조하는 가상 메모리 영역을 동일한 물리 메모리 영역에 대응 시킴으로써
  - 두 개의 프로세스가 메모리 내용을 공유한다.
  - IPC(Inter Process Communication) 공유 메모리 등은, 이 방법으로 구현된다.

또한, 이를 통해 Swap이 발생하고 있는 경우 물리 메모리가 부족하다는 증거이므로<br>
RSS의 크기를 보고 몹시 큰 프로세스가 없는지 등을 찾아본다.

# 부하란
다양한 관점에서 부하를 생각해본다.

## 두 종류의 부하
일반적으로 부하는 크게 두 가지로 분류해본다.
- CPU 부하
  - 예) 대규모 과학계산을 수행하는 프로그램
    - 디스크 입출력은 하지 않지만, 처리가 완료될 때까지 상당한 시간을 요한다.
    - 계산을 한다 = 이 프로그램의 속도는 CPU의 계산속도에 의존하고 있다.
    - CPU 바운드한 프로그램으로, CPU에 부하를 주는 프로그램
- I/O 부하
  - 예) 디스크에 의존해서 대량의 데이터로부터 임의의 문서를 찾아내는 검색 프로그램
    - 디스크에 의존 = 디스크의 읽기속도에 의존한다.
    - I/O 바운드한 프로그램으로, I/O에 부하를 주는 종류의 프로그램이다.

일반적으로 AP서버는 DB로부터 얻은 데이터를 가공해서 클라이언트로 전달하는 처리를 수행한다.<br>
AP 서버는 CPU 바운드한 서버라고 할 수 있다.

DB서버는 데이터를 디스크로부터 검색하는 것이 주된 일로, 데이터가 대규모가 되면 될수록<br>
CPU에서의 계산시간보다도 I/O에 대한 영향이 커지는 I/O 바운드한 서버다.

## 멀티 태스킹 OS와 부하
멀티태스킹 OS는 그 이름처럼 동시에 서로 다른 여러 태스크를 처리할 수 있다.<br>
여러 태스크를 실행한다고 해도 실제로는 리소스를 여러 태스크에서 공유할 필요가 있다.<br>
그래서 짧은 시간간격으로 여러 태스크를 전환해가면서 처리를 함으로써 멀티태스킹을 실현하고 있다.

실행할 태스크가 적은 상황에서 OS는 태스크에 대기를 발생하지 않고 전환을 할 수 있다.<br>
히지만 태스크가 늘어나면 특정 태스크가 CPU로 계산을 수행하고 있는 동안,<br>
다음으로 계산을 수행하고자 하는 다른 태스크들은 CPU에 시간이 날 때까지 대기하게된다.<br>
즉, `처리를 실행하려고 해도 대기한다` 라는 대기상태는 프로그램의 실행지연으로 나타난다.

Load Average는 단위시간당 대기된 태스크의 수, <br>
즉 평균적으로 어느정도의 태스크가 대기상태로 있었는지 보고하는 수치이다.<br>
(수치가 높다 = 지연되는 태스크가 많다 = 부하가 높다)
```
              1분   5분   15분
load average: 0.00, 0.01, 0.05
```

Load Average는 어디까지나 대기 태스크 수만 나타내는 수치이므로 부하가 높은 곳이 CPU인지 I/O인지를 판단할 수 없다.<br>
최종적으로 서버 리소스중 어디가 병목이 되고 있는지를 판단하려면 조금 더 자세히 조사할 필요가 있다.
- 어떤 값을 보면 OS의 병목을 판단할 수 있을까. 각각의 값은 OS가 무엇을 출력한 값일까
- Load Average가 나타내는 대기 태스크란 실제로 무엇을 기다리고 있는 태스크를 말할까
- 병목임을 알았을 때 어떤 프로세스가 부하의 원인이 되고 있는 것일까?
## 부하 정체 알기
결국 부하라는 것은 여러 태스크에 의한 서버 리소스 쟁탈의 결과로 생기는 대기 시간을 한마디로 나타낸 말인 것이다.<br>
그 정체를 알기 위해서는 `태스크가 대기되는 것은 어떤 경우인가`라는 OS의 거동, 즉 커널 동작을 이해할 필요가 있다.

태스크의 대기를 제어하는 것은, 리눅스 커널 내에서도 `프로세스 스케줄러`라는 프로그램이다.

프로세스 스케줄러는 멀티 태스킹 제어에 있어서 실행할 태스크의 우선순위를 결정해<br>
태스크를 대기시키거나 재개하는 등 커널의 중추적인 역할을 담당한다.
