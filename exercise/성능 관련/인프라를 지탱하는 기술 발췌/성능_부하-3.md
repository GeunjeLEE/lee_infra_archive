## 쓰레드와 프로세스
일반적으로 쓰레드는 프로세스보다 작은 단위이다.

프로세스 내에 여러 쓰레드를 동작시킬 수 있다.(이른바 멀티 쓰레드)
하나의 프로그램에 동시에 병행해서 복수개의 처리를 수행하고자 할 경우의 구현 테크닉으로는

1. 프로세스를 여러 개 생성해서 실행 컨텍스트를 여러 개 확보한다. -> 멀티 프로세스
2. 쓰레드를 여러 개 생성해서 실행 컨텍스트를 여러 개 확보한다. -> 멀티 쓰레드

멀티 프로세스와 멀티 쓰레드의 결정적 차이는, <br>
전자가 메모리 공간을 개별적으로 갖는데 비해 후자는 메모리 공간을 공유한다는 점이다.

따라서 메모리 사용 효율은 멀티 쓰레드가 더 높으며, 또한 프로세스 전환 시에 <br>
메모리 공간의 전환이 발생하지 않는 만큼 전환 비용이 낮아진다.<br>
대량의 실행 컨텍스트를 필요로 하는 프로그램에서는 멀티 쓰레드를 채용하는 편이 유리하다.

커널 내부에서는 프로세스와 쓰레드가 동일한 것으로 다뤄진다. <br>
쓰레드 하나에 대해 프로세스 디스크립터 하나가 할당되며 프로세스와 쓰레드는 완전히 동일한 로직으로 스케줄링 된다.

쓰레드는 커널 내부에서 LWP = Light Weight Process, 즉 경량 프로세스라고 한다.<br>
ps 명령어에서 -L 옵션을 사용하면 쓰레드 정보를 확인할 수 있는데
```
# ps auxww -L
USER       PID   LWP %CPU NLWP %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root      3386  3386  0.0   12  0.1 127628 19616 ?        Ssl  11:34   0:00 /usr/bin/amazon-ssm-agent
root      3386  3510  0.0   12  0.1 127628 19616 ?        Ssl  11:34   0:00 /usr/bin/amazon-ssm-agent
root      3386  3511  0.0   12  0.1 127628 19616 ?        Ssl  11:34   0:00 /usr/bin/amazon-ssm-agent
root      3386  3512  0.0   12  0.1 127628 19616 ?        Ssl  11:34   0:00 /usr/bin/amazon-ssm-agent
root      3386  3513  0.0   12  0.1 127628 19616 ?        Ssl  11:34   0:00 /usr/bin/amazon-ssm-agent
root      3386  3550  0.0   12  0.1 127628 19616 ?        Ssl  11:34   0:00 /usr/bin/amazon-ssm-agent
root      3386  3551  0.0   12  0.1 127628 19616 ?        Ssl  11:34   0:00 /usr/bin/amazon-ssm-agent
root      3386  3552  0.0   12  0.1 127628 19616 ?        Ssl  11:34   0:00 /usr/bin/amazon-ssm-agent
root      3386  3553  0.0   12  0.1 127628 19616 ?        Ssl  11:34   0:00 /usr/bin/amazon-ssm-agent
root      3386  3568  0.0   12  0.1 127628 19616 ?        Ssl  11:34   0:00 /usr/bin/amazon-ssm-agent
root      3386  3571  0.0   12  0.1 127628 19616 ?        Ssl  11:34   0:00 /usr/bin/amazon-ssm-agent
root      3386  3572  0.0   12  0.1 127628 19616 ?        Ssl  11:34   0:00 /usr/bin/amazon-ssm-agent
```
여기서 LWP가 쓰레드 ID, NLWP가 쓰레드의 개수이다.

## ps
ps는 프로세스가 갖는 정보를 출력하는 소프트웨어이다.<br>
이를테면 커널 내부에서 유지하는 프로세스 디스크립터에 저장된 각종 정보에, 사용자 공간에서 접근하는 도구를 말한다.

ps auxw를 출력하고, 주요 컬럼의 의미를 보면
```
# ps auxww
ps auxw
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root      2690  0.0  0.5 154716  5376 ?        Ss   11:10   0:00 sshd: vagrant [priv]
root      2694  0.0  0.5 159080  5784 ?        Ss   11:10   0:00 sshd: vagrant [priv]
vagrant   2696  0.0  0.2 155028  2596 ?        S    11:10   0:00 sshd: vagrant@pts/0
vagrant   2699  0.0  0.2 159080  2304 ?        S    11:10   0:00 sshd: vagrant@notty

```
- %CPU : 해당 프로세스의 CPU 사용률
- %MEM : 프로세스가 물리 메로리를 얼마나 소비하고 있는지를 백분율로 표시
- VSZ,RSS : 각각 해당 프로세스가 확보하고 있는 가상/물리 메모리 영역의 크기
- STAT : 프로세스의 상태
- TIME : CPU를 사용한 시간

### VSZ RSS
VSZ(Virtual Set Size)는 프로세스가 확보한 가상 메모리 영역의 크기<br>
RSS(Resident Set Size)는 물리 메모리 영역의 크기를 말한다.

리눅스의 중요한 기능으로 가상 메모리 구조가 있다.<br>
가상 메모리란 프로그램이 메모리를 사용할 때 물리적인 메모리를 직접 다루지 않고,<br>
가상 메모리를 추상화한 소프트웨어적인 메모리를 다루는 구조다.

하드웨어에서 제공하는 페이징 이라는 가상 메모리 구조를 사용해 실현하였으며, OS가 이 가상 메모리 영역을 관리한다.

1. 특정 프로세스가 메모리를 필요로 한다.
2. 사용자 프로세스는 직접 하드웨어에 접근할 수 없으므로 일단 처리를 중지하고 커널에 메모리 확보를 의뢰하게 된다.
3. 커널은 실제 물리 메모리 영역의 주소를 넘기는 것이 아니라, 가상 메모리 주소를 넘긴다.
4. 프로세스는 커널에서 반환된 가상 메모리 주소를 실제 주소인 걸로 간주하고 처리를 재개한다.

여기서 중요한 것은, 커널이 프로세스에 반환하는 가상 메모리 영역은<br>
이 시점에서는 실제로 물리 메모리와 연결되어 있지 않은 실체가 없는 메모리 영역이라는 점이다.<br>
프로세스가 커널로부터 받은 가상 메모리 영역에 대해 쓰기작업을 수행하는 시점에서 처음으로 물리 메모리 영역에 바인딩 된다.

이러한 구조를 통해 얻을 수 있는 이점으로는
- 실제 물리 메모리 용량 이상의 메모리를 다룰 수 있다.
- 메모리상에서는 흩어져 있는 영역을 연속된 하나의 메모리 영역으로 프로세스에게 보일 수 있다.
- 물리 메모리가 부족한 경우, 장시간 사용되지 않은 영역의 가상 메모리와 물리 메모리 영역의 매핑을 해제한다.
  - 해제된 데이터는 2차 기억장치에 저장해두고, 다시 필요해지면 원래로 되돌린다 = Swap
- 서로 다른 두개의 프로세스가 참조하는 가상 메모리 영역을 동일한 물리 메모리 영역에 대응 시킴으로써
  - 두 개의 프로세스가 메모리 내용을 공유한다.
  - IPC(Inter Process Communication) 공유 메모리 등은, 이 방법으로 구현된다.

또한, 이를 통해 Swap이 발생하고 있는 경우 물리 메모리가 부족하다는 증거이므로<br>
RSS의 크기를 보고 몹시 큰 프로세스가 없는지 등을 찾아본다.

## I/O 부하경감과 페이지 캐시
리눅스는 한번 디스크에서 읽어 들인 데이터는 가능한 한 메모리에 캐시를 해서<br>
다음 번 이후의 디스크 읽기가 고속으로 수행되도록 조정한다.

이렇게 메모리에 읽어들인 데이터의 캐시를 페이지 캐시라고 한다.<br>
리눅스는 메모리 영역을 4KB 블록 단위로 관리한다. 이 4KB 블록은 페이지라고 한다.<br>
즉, 디스크로부터 데이터를 읽어들이는 것은 다름아닌 페이지 캐시를 구축하는 것이다.<br>
읽어들인 데이터는 페이지 캐시에서 사용자 공간으로 전송된다.

리눅스의 페이지 캐시 동작 원리에서 기억해야할 것은
`리눅스는 가능한 한 남아있는 메모리를 페이지 캐시로 활용하려고 한다`는 원칙이다.<br>
즉 다음과 같다.
- 디스크로부터 데이터를 읽어서
- 아직 그것이 페이지 캐시에 없고
- 메모리가 남아있다면
- 오래된 캐시와 교체하는 것이 아닌 언제든 새로운 캐시를 생선한다.
- 캐시용 메모리가 없다면, 오래된 캐시를 버리고 새로운 캐시로 교체한다.

이러한 페이지 캐시의 효과는, 쉽게 말하면 데이터를 완전히 메모리에 올릴 수 있는 용량만 있다면<br>
거의 모든 액세스를 메모리로부터 읽어낼 수 있으므로, 그만큼 속도 향상을 기대할 수 있다.<br>
(DB 서버 등에서 메모리 사이즈를 중요하게 생각하는 것이 이러한 흐름과 같은 것 인가?)

## 페이지 캐시는 한 번의 read에서 시작된다.
위에서 설명한 것 처럼, 페이지 캐시는 말 그대로 캐시이므로, 캐싱하지 못한 데이터는<br>
당연히 직접 디스크에서 읽어들인다.

OS를 부팅한 직후에는 대부분의 데이터가 캐싱되지 못한 상태이므로 거의 모든 읽기 요청은<br>
캐시가 아닌 디스크로부터 전송된다.DB서버를 운용하면서, 대규모의 데이터를 처리할 경우에는 이 점에 주의해야한다.

예를 들면, 유지보수 등으로 서버를 재부팅한 경우, 메모리에 캐싱 되어있던 페이지캐시는 모두 초기화 되는데<br>
요청이 많은 DB 서버를 캐시가 구축되어 있지 않은 상태로 서비스에 투입하게되면<br>
DB 액세스는 I/O 부하를 발생시킨다.

때문에, 필요한 데이터 전체를 한번 읽어들인 후에 서비스에 투입하는 방안을 두는것도 좋다.
