## sar로 CPU사용률, I/O대기율 확인

sar가 다른 도구보다 뛰어난 점은, 부하의 지표를 시간 경과에 따라 비교해서 열람할 수 있다는 점이다.

```
# sar

12:00:01 AM CPU %user %nice %system %iowait %steal %idle
12:10:01 AM all 0.07 0.00 0.12 0.01 0.00 99.80
12:20:01 AM all 0.06 0.00 0.08 0.00 0.00 99.85
12:30:01 AM all 0.03 0.00 0.00 0.00 0.00 99.97
```
위의 예는 12:00 ~ 12:30까지의 CPU 사용률 나타낸다.<br>
만약, Load Average가 높고, 이러한 CPU 사용률이 높다면, 대기하고 있는 프로세스의 원인은<br>
CPU 리소스 부족이라고 판단할 수 있을 것이다.

## CPU의 사용자 모드와 시스템 모드
- 사용자 모드(%user)
  - 사용자 프로그램이 동작할 때의 CPU모드
  - 통상적인 애플리케이션이 동작하는 모드
- 시스템 모드(%system)
  - 시스템 모드에서의 CPU사용률
  - 시스템 프로그램 = 커널이 동작할 때의 CPU 모드

무엇보다 시스템 모드의 CPU 사용률은 프로세스나 쓰레드의 전환 횟수가 많을 경우<br>
혹은 시스템 콜을 호출하는 빈도가 높을 경우에 높아진다.

멀티 태스킹이라도 해도 커널이 짧은 시간에 프로세스를 전환하고 있을 뿐이기 때문에<br>
프로세스가 전환하는 타이밍에는 반드시 커널이 동작하게 되는 것이다.

또한, 시스템 콜을 발생시키면, 사용자 프로그램으로부터 커널로 실행 상태가 변화한다.

## I/O 바운드인 경우

%iowait는 I/O 대기율이다.<br>
Load Average이 높고, %iowait가 높은 경우, 부하의 원인이 I/O에 있다고 판단할 수 있다.

멀티코어 환경의 경우, sar의 -P 옵션을 통해 각 코어별 CPU사용률을 확인할 수 있는데<br>
멀티코어의 상황이라도, 디스크는 하나밖에 없는 경우, CPU 부하는 다른 CPU로 분산되어도<br>
I/O 부하는 분산되지 않는다.

따라서, 일반적인 sar평균 I/O대기가 20%정도로 나타난다고 했을때, 그다지 많지 않은 듯 보이지만<br>
CPU 별로 보면 그 값의 편중이 현저하게 나타난다. 

멀티코어 환경에서는 경우에 따라서는 CPU 사용률을 개별적으로 확인할 필요가 있다고 할 수 있다.

