## I/O 부하경감과 페이지 캐시
리눅스는 한번 디스크에서 읽어 들인 데이터는 가능한 한 메모리에 캐시를 해서<br>
다음 번 이후의 디스크 읽기가 고속으로 수행되도록 조정한다.

이렇게 메모리에 읽어들인 데이터의 캐시를 페이지 캐시라고 한다.<br>
리눅스는 메모리 영역을 4KB 블록 단위로 관리한다. 이 4KB 블록은 페이지라고 한다.<br>
즉, 디스크로부터 데이터를 읽어들이는 것은 다름아닌 페이지 캐시를 구축하는 것이다.<br>
읽어들인 데이터는 페이지 캐시에서 사용자 공간으로 전송된다.

리눅스의 페이지 캐시 동작 원리에서 기억해야할 것은
`리눅스는 가능한 한 남아있는 메모리를 페이지 캐시로 활용하려고 한다`는 원칙이다.
즉 다음과 같다.
- 디스크로부터 데이터를 읽어서
- 아직 그것이 페이지 캐시에 없고
- 메모리가 남아있다면
- 오래된 캐시와 교체하는 것이 아닌 언제든 새로운 캐시를 생선한다.
- 캐시용 메모리가 없다면, 오래된 캐시를 버리고 새로운 캐시로 교체한다.

이러한 페이지 캐시의 효과는, 쉽게 말하면 데이터를 완전히 메모리에 올릴 수 있는 용량만 있다면<br>
거의 모든 액세스를 메모리로부터 읽어낼 수 있으므로, 그만큼 속도 향상을 기대할 수 있다.
(DB 서버 등에서 메모리 사이즈를 중요하게 생각하는 것이 이러한 흐름과 같은 것 인가?)

## 페이지 캐시는 한 번의 read에서 시작된다.
위에서 설명한 것 처럼, 페이지 캐시는 말 그대로 캐시이므로, 캐싱하지 못한 데이터는<br>
당연히 직접 디스크에서 읽어들인다.

OS를 부팅한 직후에는 대부분의 데이터가 캐싱되지 못한 상태이므로 거의 모든 읽기 요청은<br>
캐시가 아닌 디스크로부터 전송된다.DB서버를 운용하면서, 대규모의 데이터를 처리할 경우에는 이 점에 주의해야한다.

예를 들면, 유지보수 등으로 서버를 재부팅한 경우, 메모리에 캐싱 되어있던 페이지캐시는 모두 초기화 되는데<br>
요청이 많은 DB 서버를 캐시가 구축되어 있지 않은 상태로 서비스에 투입하게되면<br>
DB 액세스는 I/O 부하를 발생시킨다.

때문에, 필요한 데이터 전체를 한번 읽어들인 후에 서비스에 투입하는 방안을 두는것도 좋다.
