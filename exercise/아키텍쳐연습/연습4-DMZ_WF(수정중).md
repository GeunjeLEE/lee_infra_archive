## 연습4 
### 이렇게
<img src="https://user-images.githubusercontent.com/19552819/99258638-35d22980-285c-11eb-8849-052d1ede1f23.png" width="800" height="800">
<hr>
<img src="https://user-images.githubusercontent.com/19552819/99258664-41255500-285c-11eb-92a9-86a925c51870.png" width="800" height="800">

### 요렇게
<img src="https://user-images.githubusercontent.com/19552819/99664876-32cd7800-2aac-11eb-9850-97c35900d2ba.png" width="800" height="800">
<hr>
<img src="https://user-images.githubusercontent.com/19552819/99664930-4678de80-2aac-11eb-81e6-2834c9df1ebc.png" width="800" height="800">

### 왜 이렇게?
- 방어
  - FW
    - 가장 앞단에 배치한다.(외부 네트워크로부터 들어오는 경로의 가장 최전선 / 외부와 내부 네트워크 경계)
    - 허가된 IP와 Port의 패킷만 접근을 허가하도록 한다.
  - IPS/IDS
    - FW의 뒤에 배치한다.
    - FW를 통한 IP/Port 제어로 패킷이 1차적으로 걸러지고, 
      - 취약점 관련 패턴을 분석하여 허가받지 않은 접근이나 해킹 시도를 감지하도록 한다.(IPS라면 차단한다.)
    - 위 구성처럼 하는 것이 아니라, Switch나 FW에 IDS를 설치하거나 서버에 직접 설치할 수도 있겠다.
  - WAF
    - 웹 어플리케이션 보안에 특화된 만큼, 웹 서버의 앞단에 배치한다.
    - HTTP 트래픽을 검사하여 SQL 인잭션이나 XSS등의 웹 공격을 차단하도록 한다.
  - 방어 내용을 보면
    - FW : 표적 공격, 포트 스캔 / 네트워크 계층에서의 공격
    - IDS/IPS : DoS, OS 취약성 / 서버, OS, 네트워크의 부정 액세스
    - WAF : SQL 인잭션, XSS / 웹 어플리케이션 취약성
  - 보안 장비를 꼭 다 넣을 필요가 있을까.
    - 보안 장비에 따라 구성도 좀 달라지는 것 같다.
      - https://www.kt-idc.com/guide/sub3_3_7.jsp
      - https://www.kt-idc.com/guide/sub3_3_6.jsp
      - https://www.kt-idc.com/guide/sub3_3_5.jsp

- 네트워크 분할
  - DMZ
    - 내부 네트워크와 외부 네트워크 사이에 위치해 내부 서버에 직접적으로 접속하지 못하게 해 부정적인 행위를 하지 못하도록 완충하는 역할을 한다.
      - 외부에 공용 서비스를 제공하면서 내부 네트워크를 보호한다.
        - 때문에 웹 서버(개발 디버딩 도구가 없는)나, Mail서버, FTP서버 등은 DMZ에 배치한다.
    - 서비스 할 포트만 제한적으로 오픈하여 DMZ로 접근하도록 한다.
      - 80, 443등의 웹 서비스 포트가 대표적이겠다.
  - 내부 네트워크
    - 외부에서 직접적으로 연결할 필요가 없는 서버를 배치한다.
      - AP(WAS등..), DB 서버 등을 내부 네트워크에 배치한다.
    - DMZ의 웹 서버등으로부터 간접적으로 접근한다.
    - 내부망으로 연결이 필요한 포트만 제한적으로 오픈한다.
      - 예로 내부 WAS로 연결해야할 경우, 해당 WAS의 포트만을 오픈한다(8080이나 8000이나...)
  - (추가로) 보호(?) 영역
    - 외부 인터넷으로의 통신조차 차단하여, 내부 서버들끼리만 접근할 수 있는 영역.
      - 민감한 데이터를 취급하는 서버를 배치한다.
        - 금융 정보를 처리하는 응용 프로그램이나, 금융 정보를 저장하는 DB등을 배치한다.
      - 외부로의 통신이 불가능하므로, 외부 repository를 이용하여 패키지를 설치/업데이트가 불가능 하다.
        - 때문에 내부 repository를 구축하여 이를 해결할 수 있도록 한다.

- 서버 배치
  - WEB
    - DMZ에 배치한다.
    - 클라이언트 요청에 대해서는
      - 정적 컨텐츠를 반환하거나
      - 요청을 캐싱하고, 이후 동일한 접근에 대해서 캐싱된 컨텐츠를 반환한다.
      - 동적 컨텐츠 등의 Logic처리가 필요한 요청 대해서는 내부 네트워크에 위치한 AP(WAS)로 전달한다.
      - 이러한 WEB군에 Nginx나 Apache등을 이용하여
        - Reverse Proxy처럼 움직이도록 하여, 클라이언트의 요청을 중계하도록 한다. -> WAS로의 직접적인 접근을 차단할 수 있다.
          - 클라이언트 <-> WEB, WEB <-> AP의 두 TCP세션이 오픈된다
        - 이미지, CSS등의 정적 컨텐츠를 WEB에서 처리하도록 하여 WAS서버의 부담을 줄일 수 있다.
        - 캐시 처리를 활성화하여, 이후 동일한 요청에 대해서는 캐시에서 반환하도록 하여 처리 속도를 높힐 수 있게 한다.
  - AP(WAS)
    - 내부 네트워크에 배치한다.
    - WEB 서버로부터 전달받은 동적 처리를 담당하여 처리한다.
    - DB와 통신한다.
    - 필요에 따라 대량의 컨텐츠를 저장/관리가 필요한 경우 스토리지 서버를 붙여 용량 증설 등의 대응을 한다.
  - DB
    - 내부 네트워크에 배치한다.
      - 혹은 아에 외부와 통신이 철저히 차단된 보호 영역에?
    - 외부로의 직접적인 접근을 막고, 동일 네트워크에 위치한 서버들로부터 요청을 받아 처리한다.
    - 대량의 데이터를 저장하고 있어, 서버 자체의 용량 증설에 한계가 있을 경우 스토리지 서버를 붙여 용량 증설 등의 대응을 한다.
      - DB서버에 스토리지 서버를 붙히는게 맞을까?
    - Replication 구성을 하여 데이터를 복제한다.
      - 모든 요청이 Master로 향하게 되면, 부담이 늘어날 수 있으므로
        - Master로는 Insert, update등의 쓰기에 대한 요청을 보내도록 하고
        - Slave로는 select등의 읽기 처리에 대한 요청을 보내도록 한다.
  - 스토리지
    - 내부 네트워크에 배치한다.
      - 혹은 아에 외부와 통신이 철저히 차단된 보호 영역에?
      - 중요한 데이터를 보관하고 있는 만큼, 외부로부터의 접근을 철저히 막는다.
    - 대용량 데이터를 처리하기 위한 서버에 연결한다.
      - AP에 대해서는 대용량 컨텐츠를 전송하는 서비스에서는 컨텐츠 파일을 저장할 위치가 가장 중요한 과제가 될 수 있으므로 고려한다.
      - 이 외에 DB서버나, 파일서버 등이 있지 않을까. 아니면 내부 리포지토리 서버.
  - 캐시(Memcached,redis등)
    - 내부 네트워크에 배치한다. 
    - HTTP레벨이 아닌 캐시를 처리한다.
      - 스토리지로는 OS의 메모리를 이용하므로, 디스크 읽기/처리 속도보다 훨씬 빠르다.
      - DB 등? 이외에는 뭐가 있을까?
    - APP에서 클라이언트 라이브러리를 이용하여 서버와 통신하면서 캐시를 확인하여 없을 경우에만 DB로 요청을 보내도록 한다.
      - 프로그래밍 언어가 규정하는 객체를 읽어오고 저장하도록 한다.

- 부하분산
 - DNS 라운드로빈
   - 동일한 이름으로 여러 레코드를 등록시키면 처리를 분산시킬 수 있다.
   - 문제점
    - 균등하게 분산되는 것은 아니다
     - 모바일 사이트 등에서 문제가 되는 경우가 있다.
       - 모바일은 캐리어 게이트웨이라는 프록시 서버를 경유한다.
         - 프록시에서는 이름 변환 결과가 일정시간 캐싱되므로
         - 같은 프록시 서버를 경유하는 접속은 항상 같은 서버로 전달된다.
       - PC 웹 브라우저에서도 DNS 질의 결과를 캐싱하기 때문에 균등하게 분산되지 않는다.
       - DNS의 TTL을 짧게 설정해서 어느 정도 개선할 수 있지만
         - 반드시 TTL을 따라 캐시를 해제하는 것이 아니므로 주의한다.
    - 서버가 다운되어도 감지하지 못한다.
        - DNS 분산은 리얼 서버의 부하나 접속 수 등의 상황에 따라 질의를 제어할 수 없다.-
    - DNS 라운드 로빈은 부하를 분산하기 위한 방법이지 다중화하는 방법은 아니므로
      - 다른 소프트웨어와 조합해서 헬스체크나 장애 극복을 마련할 필요가 있다.
 - 로드밸런서
  - 물리
    - L4
      - TCP 헤더 등의 프로토콜 내용을 분석해 분산 시킬곳을 결정한다.
      - L4에서 클라이언트가 통신하는 곳은 리얼 서버다?(요청을 그대로 전달한다.)
    - L7
      - L7계층의 내부까지 분석해 분산 시킬 곳을 결정한다.
      - L7에서는 로드밸런서와 클라이언트가 TCP 세션을 전개한다.
        - 즉, 하나의 접속에 대해서 클라이언트 <-> 로드밸런서 와 로드밸런서 <-> 리얼서버 두 TCP 세션이 전개된다.
    - 두 스위치의 특징을 단적으로 정리하면
      - 유연한 설정을 하고자 한다면 L7
      - 성능을 추구한다면 L4
  - 소프트웨어
     - HAProxy
  - 대상
    - WEB, APP, API등
      - 서버 앞단에 LB를 배치하여 분산처리 한다.
      - 부하에 따라 서버를 수평적으로 확장할 수 있다.
  - Health Check
    - 장비 정지에 의해 서비스가 정지되는 경우도 있고,APP 정지에 의해 서비스가 정지되는 경우도 있다. 
    - 문제가 생기면 분산 대상에서 제외될 수 있도록 Health Check도 실시할 수 있도록 한다.
    - 특히나 L4 계층만이 아니라 L7 계층에서도 Health Check도 실시한다.
      - WEB의 경우 Health Check 페이지를 작성해두고, 주기적으로 HTTP 요청을 보내어 확인할 수 있도록 한다.
      - DNS의 이중화가 이루어졌다면, 주기적으로 DNS Query를 보내, 타임아웃을 확인할 수 있도록 한다.
  - GSLB
    - GSLB를 이용해 Global LoadBalancing을 구성할 수도 있다.
    - 고가용성 구성은 기본이고, 재해복구 수준까지 구현할 수 있겠다.

- 이중화
  - DB
    - HW 이중화 / Replication 이중화 등의 구성을 한다.
      - Shared Disk(예 : OS Cluster / RHCS)
        - Master를 Active-Standby로 구성하고, 2대의 서버는 같은 Disk(shared disk)를 바라본다.
          - 평상시는 Master(Active)를 shared disk에 연결하고 VIP를 붙여 Mysql를 서비스한다.
          - Master(Active)가 장애가 나면 Master(Standby)를 shared disk에 연결하고 VIP를 붙여 서비스한다.
            - 평상시 Master(Standby)는 Mysql를 서비스하고 있지 않다가 장애시에 Failover용도로만 사용한다.
          - 단점
            - RHCS 솔루션 구매가 필요하고, 고비용의 Shared Disk가 필요하다.
      - Disk 복제(DRBD + Corosync + Pacemaker)
        - Master를 Active-Standby로 구성하고 각각의 Disk를 바라본다.
          - Active에 기록된 데이터는 네트워크를 통해 Standby로 Disk를 복제한다. (Sync)
            - 그러므로, Network Latency에 의해 성능에 영향을 받는다.
        - 평상시는 Master(Active)에 VIP를 붙여 Mysql를 서비스한다.
        - Shared disk방식에 비해 라이센스, 고성능의 Disk 없이 사용 가능하다.
    - Replication 이중화의 경우
      - MMM(Multi-Master Replication Manager)
        - Perl 기반의 Auto Failover Open Source
        - MMM Monitor에서 DB서버의 Health Check와 Failover를 수행한다.
        - Monitor - Agent 방식
        - 구성
          - MMM monitor
          - Master (Active) <--양방향 복제--> Master (Standby/Read-only)
  - 스토리지
    - 서버에 장착된 하드 디스크 고장에 의해 데이터가 손실되면 당연하지만 곤란한 상황이 된다.
      - RAID 구성을 이용해 하드디스크 고장에 의해 데이터가 손실되지 않도록 구성하는 것이 일반적이다.
    - 다만, 고장이 나는건 하드 디스크만이 아니다.
      - RAID 컨트롤러가 고장난 경우, 운이 나쁘면 데이터 손실이 발생할 수 있다.(예기치 않은 데이터를 덮어써서?)
    - DRBD를 이용한 스토리지 서버 다중화를 고려해볼 수 있다.
      - HA 클러스터를 구성할 때 유용한 블록 디바이스를 제공한다.
      - 가능하면 전용 네트워크를 사용해서 두 대의 컴퓨터의 블록 디바이스간 데이터를 미러링한다.
      - 네트워크를 이용한 RAID 1이라 생각하면 알기 쉽다.
      - DRBD는 파일단위로 데이터를 전송하는게 아니라
        - 블록 디바이스에 대해 변경사항을 실시간으로 전송한다.
      - DRBD는 마스터 서버에 문제가 발생하더라도 자동으로 Failover를 하지 않는다.
        - 장애극복 솔루션과 결합이 필요하다.
      - 미러링하더라도, 백업은 필요하다.
        - 실수로 데이터를 삭제하면 백업에도 바로 반영이 되므로
        - 최악의 경우를 대비해 박업은 해두자.
  - LB
    - VRRP를 이용해 다중화 한다.
    - Active 장비에 VIP를 붙여 서비스하고
      - Active인 서버가 다운되면 VIP가 standby로 할당되면서 failover를 한다.
  
     